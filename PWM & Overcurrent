#include <msp430fr6989.h>

/* ===== USER TUNABLES ===== */
#define PWM_PERIOD        1000u      /* ~1 kHz @ ~1 MHz SMCLK */
#define DUTY_FORWARD      700u
#define DUTY_TURN         900u
#define CYCLES_CAL_1FT    2000000u   /* tune for ~1 ft */
#define CYCLES_CAL_TURN90 2000000u   /* tune for ~90° */

static void delay_ms(unsigned int ms){ while(ms--) __delay_cycles(1000); }

/* ===== YOUR WIRING =====
   IN1 = P1.5, IN2 = P2.4, IN3 = P2.5 (broken, pulled low), IN4 = P2.6
   ENA = P3.3 (TA1.1)  -> ALTERNATE mapping (SEL1=1, SEL0=0)
   ENB = P3.6 (TB0.2)  -> ALTERNATE mapping (SEL1=1, SEL0=0)

   eCOMP current sense:
   Left motor sense (SENSA shunt node)  -> P8.4  (C7)  [A7/C7]   <-- analog/comparator input
   Right motor sense (SENSB shunt node) -> P8.5  (C6)  [A6/C6]   <-- analog/comparator input
*/

/* -------- Direction helpers (MATCH YOUR FORWARD: IN2 & IN4 HIGH) -------- */
static void coast_all(void){
    P1OUT &= ~BIT5;   /* IN1=0 */
    P2OUT &= ~BIT4;   /* IN2=0 */
    P2OUT &= ~BIT6;   /* IN4=0 (IN3 already 0) */
}

/* Forward both = A forward via IN2=1 (IN1=0), B forward via IN4=1 (IN3=0) */
static void forward_both(void){
    /* Motor A forward (your polarity): IN1=0, IN2=1 */
    P1OUT &= ~BIT5;
    P2OUT |=  BIT4;

    /* Motor B forward-only: IN3=0, IN4=1 */
    P2OUT |=  BIT6;
}

/* Pivot left in place = A reverse (IN1=1, IN2=0) + B forward (IN4=1) */
static void pivot_left_in_place(void){
    /* Motor A reverse (opposite of your forward): IN1=1, IN2=0 */
    P1OUT |=  BIT5;
    P2OUT &= ~BIT4;

    /* Motor B forward: IN3=0, IN4=1 */
    P2OUT |=  BIT6;
}

static void brake_short(void){          /* optional snappy stop */
    P1OUT |=  BIT5;   /* A: IN1=1 */
    P2OUT |=  BIT4;   /* A: IN2=1  (active brake on A) */
    P2OUT |=  BIT6;   /* B: IN4=1  (adds drag; IN3 is 0) */
    delay_ms(80);
    coast_all();
}

/* -------- Init -------- */
static void io_init(void){
    PM5CTL0 &= ~LOCKLPM5;

    /* IN pins as GPIO */
    P1DIR |= BIT5; P1SEL0 &= ~BIT5; P1SEL1 &= ~BIT5;         /* IN1 */
    P2DIR |= BIT4 | BIT6;                                     /* IN2, IN4 */
    P2SEL0 &= ~(BIT4 | BIT6); P2SEL1 &= ~(BIT4 | BIT6);

    /* IN3 broken: input + pulldown so it stays 0 */
    P2DIR &= ~BIT5; P2REN |= BIT5; P2OUT &= ~BIT5;

    coast_all();
}

static void timers_init(void){
    /* TA1 -> ENA (CCR1) */
    TA1CCR0  = PWM_PERIOD - 1;
    TA1CCTL1 = OUTMOD_7;
    TA1CCR1  = 0;
    TA1CTL   = TASSEL_2 | MC_1 | TACLR;

    /* TB0 -> ENB (CCR2) */
    TB0CCR0  = PWM_PERIOD - 1;     /* also serves as a 1 kHz timebase */
    TB0CCTL2 = OUTMOD_7;
    TB0CCR2  = 0;
    TB0CTL   = TBSSEL_2 | MC_1 | TBCLR;
}

/* EN pins: ALTERNATE function mapping (SEL1=1, SEL0=0) */
static void en_map_alternate(void){
    /* ENA: P3.3 -> TA1.1 */
    P3DIR  |= BIT3;  P3SEL0 &= ~BIT3;  P3SEL1 |=  BIT3;
    /* ENB: P3.6 -> TB0.2 */
    P3DIR  |= BIT6;  P3SEL0 &= ~BIT6;  P3SEL1 |=  BIT6;
}

static void set_ena(unsigned int d){ if(d>PWM_PERIOD) d=PWM_PERIOD; TA1CCR1 = d; }
static void set_enb(unsigned int d){ if(d>PWM_PERIOD) d=PWM_PERIOD; TB0CCR2 = d; }

/* ----------------------- SAFETY ADD-ON (eCOMP) ----------------------- */
/* Tunables */
#define OC_PERSIST_MS  50u      /* require OC for 50 ms before tripping */

/* State */
static volatile unsigned char fault_latched = 0;
static volatile unsigned int  oc_count_A = 0, oc_count_B = 0;  /* ms counters */
static volatile unsigned char mux_sel = 0; /* 0: sample C7 (left), 1: sample C6 (right) */

/* Immediately stop motors (usable from ISRs) */
static inline void emergency_stop(void){
    set_ena(0);
    set_enb(0);
    coast_all();
    fault_latched = 1;
}

/* Route P8.4 (C7) & P8.5 (C6) to analog/comparator function */
static void ecomp_pins_init(void){
    /* P8.4 and P8.5 are A7/C7 and A6/C6 respectively (valid Comp_E inputs). */
    P8SEL0 |= BIT4 | BIT5;
    P8SEL1 |= BIT4 | BIT5;   /* analog function on both pins */
    /* No pullups/pulldowns; these are analog nodes. */
}

/* Enable Comp_E with internal reference on the negative input.
   NOTE: Threshold is set as a fraction of VCC using CECTL2.
   You can adjust the fraction (CEREF bits) to match your stall current. */
static void ecomp_init(void){
    /* Power mode: normal; turn on comparator. */
    CECTL1 = CEPWRMD_2;                  /* normal power mode */

    /* Negative input = internal reference; positive input = (we'll mux C7/C6 in ISR) */
    /* Start with C7 (+). */
    CECTL0 = CEIPEN | CEIPSEL_7 | CEIMEN;  /* + input enable on C7; - input uses internal ref via CECTL2 */

    /* Internal reference: pick a fraction of VCC (example ~8/32 = 0.25*VCC).
       Tweak these bits to set your trip point. */
    CECTL2 = CEREFL_2 | CERS_1 | CEREF0_8; /* reference ladder, ~0.25*VCC (adjust as needed) */

    /* Enable comparator */
    CECTL1 |= CEON;
}

/* Reuse TB0 CCR0 (already the PWM period) as a 1 kHz heartbeat for persistence.
   IMPORTANT: This does not change your PWM—CCR2 still runs the ENB PWM. */
static void safety_timer_init(void){
    TB0CCTL0 = CCIE;   /* enable CCR0 interrupt at 1 kHz (PWM period boundary) */
}

/* ----------------------- Main (your movement kept intact) ----------------------- */
int main(void){
    WDTCTL = WDTPW | WDTHOLD;

    io_init();
    timers_init();
    en_map_alternate();

    /* SAFETY: bring up eCOMP + 1 ms persistence tick */
    ecomp_pins_init();
    ecomp_init();
    safety_timer_init();

    /* 1) Forward ~1 ft (IN2 & IN4 high via helpers) */
    forward_both();
    set_ena(DUTY_FORWARD);
    set_enb(DUTY_FORWARD);
    __delay_cycles(CYCLES_CAL_1FT);

    brake_short();
    delay_ms(150);

    /* 2) Pivot ~90° left: A reverse + B forward */
    pivot_left_in_place();
    set_ena(DUTY_TURN);
    set_enb(DUTY_TURN);
    __delay_cycles(CYCLES_CAL_TURN90);

    /* 3) Stop */
    coast_all();
    set_ena(0);
    set_enb(0);

    while(1){ __no_operation(); }
}

/* ----------------------- ISRs (safety only) ----------------------- */
/* TB0 CCR0 @ 1 kHz:
   - Sample comparator output (CEOUT) for one channel per tick (time-multiplex C7/C6)
   - Apply 50 ms persistence per motor
   - Latch fault and stop immediately if either persists */
#pragma vector = TIMER0_B0_VECTOR
__interrupt void TB0_CCR0_ISR(void){
    unsigned char oc_now = (CECTL1 & CEOUT) ? 0u : 1u;  /* CEOUT=1 => + > ref (safe); CEOUT=0 => fault */

    if(!mux_sel){
        /* Sampling LEFT (C7 on P8.4) */
        if(oc_now){ if(oc_count_A < 0xFFFF) ++oc_count_A; } else oc_count_A = 0;
    }else{
        /* Sampling RIGHT (C6 on P8.5) */
        if(oc_now){ if(oc_count_B < 0xFFFF) ++oc_count_B; } else oc_count_B = 0;
    }

    /* Trip if either channel has persisted long enough */
    if(!fault_latched && (oc_count_A >= OC_PERSIST_MS || oc_count_B >= OC_PERSIST_MS)){
        emergency_stop();   /* zero PWMs + coast immediately */
    }

    /* Switch the comparator + input for next ms (C7 <-> C6) */
    mux_sel ^= 1u;
    if(!mux_sel){
        CECTL0 = (CECTL0 & ~(CEIPSEL0|CEIPSEL1|CEIPSEL2|CEIPSEL3|CEIPSEL4)) | CEIPSEL_7 | CEIPEN | CEIMEN;
    }else{
        CECTL0 = (CECTL0 & ~(CEIPSEL0|CEIPSEL1|CEIPSEL2|CEIPSEL3|CEIPSEL4)) | CEIPSEL_6 | CEIPEN | CEIMEN;
    }

    TB0CCTL0 &= ~CCIFG; /* clear CCR0 flag */
}
