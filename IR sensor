#include <msp430f5529.h>

#define SMCLK_HZ   1000000UL   // default DCO ~1 MHz
#define CARRIER_HZ 38000UL     // 38 kHz
#define DUTY_PCT   33UL        // ~1/3 duty helps avoid receiver AGC issues

// Gate pattern: ~1 Hz (150 ms ON, 850 ms OFF) using SMCLK/64
#define TICKS_PER_SEC   (SMCLK_HZ/64UL)
#define ON_TICKS        (TICKS_PER_SEC * 150UL / 1000UL)   // 150 ms
#define OFF_TICKS       (TICKS_PER_SEC - ON_TICKS)         // ~850 ms

static inline void carrier_start(void){
    // Route TA0.3 to P1.4 and run PWM
    P1SEL  |= BIT4;                    // P1.4 peripheral function
    TA0CCR0  = (SMCLK_HZ / CARRIER_HZ) - 1;              // period
    TA0CCR3  = ((TA0CCR0 + 1UL) * DUTY_PCT) / 100UL;     // duty
    TA0CCTL3 = OUTMOD_7;                                   // Reset/Set
    TA0CTL   = TASSEL_2 | MC_1 | TACLR;                    // SMCLK, up
}

static inline void carrier_stop(void){
    // Fully silence output (no residual carrier)
    TA0CTL   &= ~MC_3;           // stop TimerA0
    TA0CCTL3  = OUTMOD_0;        // detach PWM control
    P1SEL    &= ~BIT4;           // GPIO mode
    P1DIR    |=  BIT4;
    P1OUT    &= ~BIT4;           // drive low (MOSFET off)
}

int main(void){
    WDTCTL = WDTPW | WDTHOLD;

    // TimerA1 drives ON/OFF windows @ SMCLK/64
    TA1CTL   = TASSEL_2 | ID_3 | TACLR;  // SMCLK/8
    TA1EX0   = TAIDEX_7;                 // /8 -> total /64
    TA1CCR0  = ON_TICKS;                 // start in ON window
    TA1CCTL0 = CCIE;
    TA1CTL  |= MC_1;                     // up mode

    __bis_SR_register(GIE);

    // Start sending IR bursts
    carrier_start();

    for(;;) __no_operation();
}

#pragma vector=TIMER1_A0_VECTOR
__interrupt void TA1_ISR(void){
    static unsigned char on = 1;
    if(on){
        // Switch to OFF window
        carrier_stop();
        TA1CCR0 = OFF_TICKS;
        on = 0;
    }else{
        // Switch to ON window
        carrier_start();
        TA1CCR0 = ON_TICKS;
        on = 1;
    }
}
