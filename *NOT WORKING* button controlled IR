#include <msp430.h>
#include <stdint.h>
#include <stdbool.h>

/* ===== carrier setup ===== */
#define SMCLK_HZ     1000000UL            /* FR6989 ~1 MHz default */
#define PWM_HZ       38000UL              /* 38 kHz carrier */
#define CCR0_VAL     ((SMCLK_HZ / PWM_HZ) - 1)  /* ~25 -> 1e6/(25+1)=38.46k */
#define CCR1_VAL     (CCR0_VAL / 2)              /* ~50% duty */
#define USE_ALT_MUX  1                    /* P3.3 uses alt mux for TA1.1 on your board */

/* ===== button pins (active-HIGH, internal pulldown) ===== */
#define BTN_FWD_BIT    BIT3   /* P2.3 */
#define BTN_BACK_BIT   BIT1   /* P3.1 */
#define BTN_LEFT_BIT   BIT0   /* P3.0 */
#define BTN_RIGHT_BIT  BIT3   /* P1.3 */

/* ===== burst shape (TSOP-friendly) ===== */
#define BURST_ON_US    600u
#define BURST_OFF_US   600u

/* ===== delay helpers ===== */
static inline void delay_us(uint16_t us){ while(us--) __delay_cycles(SMCLK_HZ/1000000UL); }
static inline void delay_ms(uint16_t ms){ while(ms--) __delay_cycles(SMCLK_HZ/1000UL); }

/* ===== map P3.3 -> TA1.1 (PWM out) ===== */
static void map_p33_to_ta11(void){
    P3DIR |= BIT3;
#if USE_ALT_MUX
    P3SEL0 &= ~BIT3;   /* alt mux */
    P3SEL1 |=  BIT3;
#else
    P3SEL0 |=  BIT3;   /* primary mux */
    P3SEL1 &= ~BIT3;
#endif
}

/* ===== Timer_A1 PWM on TA1.1 ===== */
static void ta1_start_pwm(void){
    TA1CCR0  = CCR0_VAL;
    TA1CCTL1 = OUTMOD_7;                         /* reset/set */
    TA1CCR1  = CCR1_VAL;
    TA1CTL   = TASSEL__SMCLK | MC__UP | TACLR;   /* SMCLK, up mode */
}

/* ===== gate PWM on/off cleanly ===== */
static inline void pwm_on(void){  TA1CCTL1 = OUTMOD_7; }
static inline void pwm_off(void){ TA1CCTL1 = 0; P3OUT &= ~BIT3; }

/* ===== buttons: inputs w/ INTERNAL PULLDOWNS (pressed = HIGH) ===== */
static void buttons_init_active_high(void){
    /* P2.3 */
    P2DIR &= ~BTN_FWD_BIT;
    P2REN |=  BTN_FWD_BIT;   /* enable resistor */
    P2OUT &= ~BTN_FWD_BIT;   /* select pulldown */

    /* P3.1 + P3.0 */
    P3DIR &= ~(BTN_BACK_BIT | BTN_LEFT_BIT);
    P3REN |=  (BTN_BACK_BIT | BTN_LEFT_BIT);
    P3OUT &= ~(BTN_BACK_BIT | BTN_LEFT_BIT);

    /* P1.3 */
    P1DIR &= ~BTN_RIGHT_BIT;
    P1REN |=  BTN_RIGHT_BIT;
    P1OUT &= ~BTN_RIGHT_BIT;
}

/* ===== debounced read: active-HIGH ===== */
static bool btn_high_stable(uint8_t port, uint8_t bit){
    if(port == 1){
        if(P1IN & bit){ delay_ms(8); return (P1IN & bit)!=0; }
    } else if(port == 2){
        if(P2IN & bit){ delay_ms(8); return (P2IN & bit)!=0; }
    } else if(port == 3){
        if(P3IN & bit){ delay_ms(8); return (P3IN & bit)!=0; }
    }
    return false;
}

/* ===== send IR burst train ===== */
static void send_burst_train(uint16_t on_us, uint16_t off_us, uint16_t count){
    uint16_t i;  /* C89-compatible */
    for(i=0; i<count; i++){
        pwm_on();  delay_us(on_us);
        pwm_off(); delay_us(off_us);
    }
}

int main(void){
    WDTCTL  = WDTPW | WDTHOLD;   /* stop watchdog */
    PM5CTL0 &= ~LOCKLPM5;        /* unlock FR GPIOs */

    map_p33_to_ta11();
    ta1_start_pwm();
    pwm_off();                   /* idle: no carrier */
    buttons_init_active_high();

    for(;;){
        if(btn_high_stable(2, BTN_FWD_BIT)){      /* P2.3 -> forward */
            send_burst_train(BURST_ON_US, BURST_OFF_US, 60);
            while(P2IN & BTN_FWD_BIT);            /* wait release */
            delay_ms(50);
        }
        if(btn_high_stable(3, BTN_BACK_BIT)){     /* P3.1 -> back */
            send_burst_train(BURST_ON_US, BURST_OFF_US, 120);
            while(P3IN & BTN_BACK_BIT);
            delay_ms(50);
        }
        if(btn_high_stable(3, BTN_LEFT_BIT)){     /* P3.0 -> left */
            send_burst_train(BURST_ON_US, BURST_OFF_US, 30);
            while(P3IN & BTN_LEFT_BIT);
            delay_ms(50);
        }
        if(btn_high_stable(1, BTN_RIGHT_BIT)){    /* P1.3 -> right */
            send_burst_train(BURST_ON_US, BURST_OFF_US, 200);
            while(P1IN & BTN_RIGHT_BIT);
            delay_ms(50);
        }
    }
}
